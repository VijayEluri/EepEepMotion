/* this mode creates an animation that attempts to use all of the pictures exactly once, with the monkey's path determined procedurally.
 * the basic idea is to take all of the monkey pictures, and sort them into 'buckets' for some attribute, say x-coordinate.
 * within each bucket, the monkeypics are then sorted into sub-buckets based on another attribute, say size.
 * those are subdivided into angle buckets.
 * The animation is generated by walking through the buckets in such a way as to create a smooth animation.
 */

interface RecursiveBucketProcessor {
  LinkedList[] postProcess(LinkedList[] buckets, int parentBucket);
  int bucketNum(Frame frame);  
  int numBuckets();
}

class QuadrantBuckets implements RecursiveBucketProcessor {
  int numBuckets() {
    return 9;
  }
  int bucketNum(Frame frame) {
    int xpart, ypart;
    
    Monkey m = frame.monkey;
    MonkeyPic mp = frame.mp;
    
    // x bucket
    xpart = m.x*3/mp.width;
    if(xpart < 0) {xpart = 0;}
    if(xpart > 2) {xpart = 2;}

    // y bucket
    ypart = m.y*3/mp.height;
    if(ypart < 0) {ypart = 0;}
    if(ypart > 2) {ypart = 2;}

    // FIXME: move to postprocess
    m.x = width/6 + xpart*width/3;
    m.y = height/6 + ypart*height/3;
    
    return(xpart*3 + ypart);
  }
  LinkedList[] postProcess(LinkedList[] buckets, int parentBucket) {
    for(int i=0; i<buckets.length; i++) {
      println("quadrant bucket " + i + ": " + buckets[i].size());
    }
    return buckets;
  }
}

class ThirdBuckets implements RecursiveBucketProcessor {
  int numBuckets() {
    return 3;
  }
  int bucketNum(Frame frame) {
    int xpart, ypart;
    
    Monkey m = frame.monkey;
    MonkeyPic mp = frame.mp;
    
    // x bucket
    xpart = floor((float)m.x/mp.width*3.0);
    if(xpart < 0) {xpart = 0;}
    if(xpart > 2) {xpart = 2;}
    
    return(xpart);
  }
  LinkedList[] postProcess(LinkedList[] buckets, int parentBucket) {
    buckets[1] = Util.reversedLinkedList(buckets[1]);
    
    for(int i=0; i<buckets.length; i++) {
      int startx, starty;
      int endx, endy;
      if (i == 0) {startx = width/6; endx = width/3;
                   starty = height/2; endy = height/2;}
 //                  starty = height/2-height/6; endy = height/2+height/6; }
      else if (i == 1) {startx = width/3; endx = 2*width/3; 
                        starty = height/2; endy = height/2;}
//                        starty = height/2+height/6; endy = height/2-height/6; }                      
      else {startx = 2*width/3; endx = 5*width/6;
            starty = height/2; endy = height/2;}
//            starty = height/2-height/6; endy = height/2+height/6; }
      println("thirds bucket " + i + ": " + buckets[i].size() + ", startx:" + startx + " endx:" + endx);
      
      float dx = (endx-startx)/(buckets[i].size());
      float dy = (endy-starty)/(buckets[i].size());
      int ctr = 0;      
      for(Iterator j=buckets[i].iterator(); j.hasNext();) {
        Frame f = (Frame)j.next();
        f.monkey.x = (int)((endx-startx)*ctr/buckets[i].size() + startx);
        f.monkey.y = (int)((endy-starty)*ctr/buckets[i].size() + starty);
        println(f.monkey.x);
        ctr++;
      }
    }
    return buckets;
  }
}

class SizeBuckets implements RecursiveBucketProcessor {
  int numBuckets() {
    return ceil(log(300)/log(this.maxMult));
  }
  
  float maxMult = 2.5;
  int bucket0sz = 32;
  
  int bucketNum(Frame frame) {
    if (frame.monkey.size <= bucket0sz) {
      return 0;
    }
    int rv = floor(log(frame.monkey.size-bucket0sz)/log(maxMult));
    if (rv >= this.numBuckets()) {
      rv = this.numBuckets() - 1;
    }
    return rv;
  }
  LinkedList[] postProcess(LinkedList[] buckets, int parentBucket) {
    for(int bucket=0; bucket<buckets.length; bucket++) {
      int minSz = bucket0sz + floor(pow(maxMult, bucket));
      int maxSz = bucket0sz + ceil(pow(maxMult, bucket+1));
      float delta = (maxSz - minSz) / (buckets[bucket].size() + 1);
      
      float sz = minSz + delta;
      for(Iterator i=buckets[bucket].iterator(); i.hasNext();) {
        Frame f = (Frame)i.next();
        f.monkey.size = ceil(sz);
        sz += delta;
      }     
      
//      println("size bucket " + bucket + ": " + buckets[bucket].size());
    }
    return buckets;
  }  
}

class AngleBuckets implements RecursiveBucketProcessor {
  int numBuckets() {
    return 360/5;
  }
  
  int bucketNum(Frame frame) {
    PVector v = frame.monkey.z_axis.get();
    v.y = 0; // project onto xz plane
    
    int rv = (int)degrees(PVector.angleBetween(v, new PVector(0, 0, 1)));
    if (v.x < 0) { rv = -rv; }
    rv += 180;
    return rv/this.numBuckets();
  }
  
  LinkedList[] postProcess(LinkedList[] buckets, int parentBucket) {
    if((parentBucket % 2) == 1) { 
      buckets = (LinkedList[])reverse(buckets); 
    }
//    for(int bucket=0; bucket<buckets.length; bucket++) {
//      println("Angle bucket " + bucket + ": " + buckets[bucket].size());
//    }
    return buckets;
  }  
}

class UpDnBuckets implements RecursiveBucketProcessor {
  int numBuckets() {
    return 5;
  }
  
  int bucketNum(Frame frame) {
    return floor((frame.monkey.z_axis.y + 1.0)/this.numBuckets());
  }
  
  LinkedList[] postProcess(LinkedList[] buckets, int parentBucket) {
    if((parentBucket % 2) == 1) { 
      buckets = (LinkedList[])reverse(buckets); 
    }
//    for(int bucket=0; bucket<buckets.length; bucket++) {
//      println("UpDn bucket " + bucket + ": " + buckets[bucket].size());
//    }
    return buckets;
  }    
}

LinkedList applyBucketProcessors(LinkedList frames, LinkedList bucketProcessors, int processorDepth, int parentBucket) {
  if(processorDepth >= bucketProcessors.size()) {
    return (LinkedList)frames.clone(); 
  } else {
    RecursiveBucketProcessor rbp = (RecursiveBucketProcessor)bucketProcessors.get(processorDepth); // ICK O(n), but shouldn't matter
    
    // create buckets
    LinkedList[] buckets = new LinkedList[rbp.numBuckets()];
    for(int i=0; i<buckets.length; i++) { buckets[i] = new LinkedList(); }
    
    // sort into buckets
    for(Iterator i=frames.iterator(); i.hasNext();) {
      Frame f = (Frame)i.next();
      buckets[rbp.bucketNum(f)].addLast(f);
    }
    
    // process buckets
    for(int i=0; i<buckets.length; i++) {
      buckets[i] = applyBucketProcessors(buckets[i], bucketProcessors, processorDepth+1, i);
    }
    
    buckets = rbp.postProcess(buckets, parentBucket);
    LinkedList rv = new LinkedList();
    for(int i=0; i<buckets.length; i++) {
      rv.addAll(buckets[i]);
    }
    
    return rv;
  }
}

class AnimateMode extends Mode {
  Frame[] frames;
  int i = 0;
  MovieMaker mm;
  
  void enterMode() {
    // set movie file
    JFileChooser chooser;
    if (Globals.mps.dir != null) {
      chooser = new JFileChooser(Globals.mps.dir);
    } else {
      chooser = new JFileChooser();
    }
    chooser.setFileFilter(chooser.getAcceptAllFileFilter());   
    File moviefile;
    int returnVal = chooser.showSaveDialog(null);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
      moviefile = chooser.getSelectedFile();
      mm = new MovieMaker(Globals.applet, width, height, moviefile.getPath(),
                  Globals.eepEepConfig.getTargetRate(), MovieMaker.ANIMATION, MovieMaker.BEST);
    }
    
    LinkedList bucketProcessors = new LinkedList();
//    bucketProcessors.addLast(new QuadrantBuckets());
    bucketProcessors.addLast(new ThirdBuckets());
    bucketProcessors.addLast(new SizeBuckets());
    bucketProcessors.addLast(new AngleBuckets());
    bucketProcessors.addLast(new UpDnBuckets());
    
    LinkedList frameList = new LinkedList();
    for(Iterator i=Globals.mps.iterator(); i.hasNext();) {
      MonkeyPic mp = (MonkeyPic)i.next();
      Monkey m = new Monkey(mp.monkey);
      
      // FIXME scale so nothing is cropped after moving to bucket      
      match_mp_to_screen(mp);
      m.size *= mp.scale_factor;
      m.size++; // significant rounding error due to monkey.size being int. err on side of too big
      
      // rotate so that monkey's y axis has no x component
      PVector yaxis = m.y_axis.get();
      yaxis.z = 0; // project onto xy plane
      yaxis.normalize(); // not sure if necessary. shouldn't be...
      float rz = PVector.angleBetween(yaxis, new PVector(0, 1, 0));
      if (yaxis.x < 0) {rz = -rz; }
      //if (PVector.angleBetween(yaxis, new PVector(1, 0, 0)) < HALF_PI) { rz = -rz; }
      m.rotate(new PVector(0, 0, 1), rz);
      mp.rz = rz;
            
      Frame f = new Frame();
      f.mp = mp;
      f.monkey = m;
      
      frameList.addLast(f);
    }
    
    frameList = applyBucketProcessors(frameList, bucketProcessors, 0, 0);
    frames = new Frame[frameList.size()];
    
    // eww
    Iterator i=frameList.iterator();
    int j=0;
    while(i.hasNext()) { frames[j++] = (Frame)i.next(); }

/*    
    Iterator i = mps.iterator();
    int j = 0;
    while (i.hasNext()) {
      MonkeyPic mp = (MonkeyPic)i.next();
      Monkey m = new Monkey(mp.monkey);
      

      int part;
      // move to x bucket
      part = m.x*3/mp.width;
      if(part < 0) {part = 0;}
      if(part > 2) {part = 2;}
      m.x = (part+1)*width/4;
      
      // move to y bucket
      part = m.y*3/mp.height;
      if(part < 0) {part = 0;}
      if(part > 2) {part = 2;}
      m.y = (part+1)*height/4;
       
      // FIXME scale so nothing is cropped after moving to bucket      
      match_mp_to_screen(mp);
      m.size *= mp.scale_factor;
      m.size++; // significant rounding error due to monkey.size being int. err on side of too big
      
      Frame f = new Frame();
      f.mp = mp;
      f.monkey = m;
      // center it
      //mp.x = (width - mp.width*mp.scale_factor)/2.0;
      //mp.y = (height - mp.height*mp.scale_factor)/2.0;

      
      
      frames[j++] = f;
    }
    Arrays.sort(frames, new FrameComparator());
    loop();
*/
  }
  void leaveMode() {
  }    
  void draw() {
    background(0);
    ortho(-width/2, width/2, -height/2, height/2, -10, 10);

    float rz = frames[i].mp.rz;
    match_mp_to_m(frames[i].mp, frames[i].monkey);
    frames[i].mp.rz = rz;
    
    frames[i].mp.draw();
    mm.addFrame();
//    mm.addFrame();
//    mm.addFrame();
    frames[i].mp.clear_cache();
    
    /*
    pushMatrix();
    lights();
    frames[i].monkey.move_to();
    frames[i].monkey.draw();
    popMatrix();
    */
    
    i++;
    if (i >= frames.length) {
      mm.finish();
      noLoop();
    }
  }
  void keyPressed() {
    if (key == ']') {
      frames[i].mp.clear_cache();
      i++;
      if (i > frames.length) {
        i = 0;
      }
      redraw();
    } else if (key == '[') {
      frames[i].mp.clear_cache();
      i--;
      if (i < 0) {
        i = frames.length - 1;
      }
      redraw();
    }
  }
  void keyReleased() {
  }
 
}

class FrameComparator implements Comparator {
  int compare(Object o1, Object o2) {
    Frame f1 = (Frame)o1;
    Frame f2 = (Frame)o2;
    
    int res = 0;
    int b1 = 0;
    int b2 = 0;

    if (res == 0) {
      b1 = f1.monkey.x;
      b2 = f2.monkey.x;
      res = b1 - b2;
    }
    if (res == 0) {
      b1 = f1.monkey.y;
      b2 = f2.monkey.y;
      res = b1 - b2;
    } 
    if (res == 0) {
      b1 = f1.monkey.size/50;
      b2 = f2.monkey.size/50;
      res = b1 - b2;
    }
    if (res == 0) {
      boolean rev = b1 % 2 == 0;
      
      // project onto xz plane first
      PVector v1 = f1.monkey.z_axis.get();
      v1.y = 0;
      PVector v2 = f2.monkey.z_axis.get();
      v2.y = 0;
      b1 = (int)degrees(PVector.angleBetween(v1, new PVector(0, 0, 1)))/20;
      if(v1.x < 0) { b1 = -b1; }
      b2 = (int)degrees(PVector.angleBetween(v2, new PVector(0, 0, 1)))/20;
      if(v2.x < 0) { b2 = -b2; }
      res = b1 - b2;
      if (rev) {res = -res; } // rotate back and forth
    }
    if (res == 0) {
      boolean rev = b1 % 2 == 0;
      
      b1 = (int)(f1.monkey.z_axis.y * 5);
      b2 = (int)(f2.monkey.z_axis.y * 5);
      res = b1 - b2;
      if (rev) {res = -res; }
    }
    return res;
  }
  boolean equals(Object obj) {
    return (obj == this);
  }
}
